import React, { useState, useEffect, useCallback, useMemo, memo, lazy, Suspense } from 'react';
import Head from 'next/head';
// Optimized date handling - using native Date for better performance
const formatDate = (date) => {
    return new Date(date).toISOString().split('T')[0];
};

const formatDisplayDate = (date) => {
    return new Date(date).toLocaleDateString('vi-VN');
};

// CSS Modules
import styles from '../styles/soicauBayesian.module.css';

// Components
import Layout from '../components/Layout';
import LoadingSpinner from '../components/LoadingSpinner';
import ErrorMessage from '../components/ErrorMessage';
import PerformanceMonitor from '../components/PerformanceMonitor';
// Lazy load heavy components for better performance
const ProbabilityStatistics = lazy(() => import('../components/ProbabilityStatistics'));

// Utils
import { fetchWithRetry, handle429Error } from '../utils/apiUtils';

// API Service
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';

const SoiCauBayesian = () => {
    // State management
    const [selectedDate, setSelectedDate] = useState(formatDate(new Date()));
    const [selectedMethod, setSelectedMethod] = useState('ensemble'); // Always use ensemble
    // Force method to ensemble - no user choice
    const FORCED_METHOD = 'ensemble';
    const [selectedType, setSelectedType] = useState('de');
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [activeTab, setActiveTab] = useState('predictions'); // Ch·ªâ c√≥ tab predictions
    const [currentPredictions, setCurrentPredictions] = useState(null);
    const [dataDescription, setDataDescription] = useState(null);
    const [dataCreationLoading, setDataCreationLoading] = useState(false);
    // State ƒë·ªÉ track ng√†y hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω
    const [currentProcessingDate, setCurrentProcessingDate] = useState(formatDate(new Date()));
    // State ƒë·ªÉ track xem c√≥ d·ªØ li·ªáu cho ng√†y ƒë∆∞·ª£c ch·ªçn kh√¥ng
    const [hasDataForSelectedDate, setHasDataForSelectedDate] = useState(false);
    // Th√™m states m·ªõi
    const [extendedFeatures, setExtendedFeatures] = useState(null);
    const [lstmStats, setLstmStats] = useState(null);


    // Fetch soi c·∫ßu by date
    const fetchSoiCauByDate = useCallback(async (date) => {
        try {
            setLoading(true);
            setError(null);

            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/date/${date}`);
            const result = await response.json();

            if (result.success) {
                return result.data;
            } else {
                throw new Error(result.message || 'Kh√¥ng t√¨m th·∫•y soi c·∫ßu cho ng√†y n√†y');
            }
        } catch (err) {
            console.error('Soi c·∫ßu fetch error:', err);
            setError(handle429Error(err));
            return null;
        } finally {
            setLoading(false);
        }
    }, []);

    // Fetch predictions
    const fetchPredictions = useCallback(async (method, type, date, limit = 20) => {
        try {
            const params = new URLSearchParams({
                limit: limit.toString(),
                date: date
            });

            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/predictions/${method}/${type}?${params}`);
            const result = await response.json();

            if (result.success) {
                // API tr·∫£ v·ªÅ array predictions, c·∫ßn wrap th√†nh object
                return {
                    method: method,
                    type: type,
                    predictions: result.data.predictions || result.data
                };
            } else {
                throw new Error(result.message || 'L·ªói khi t·∫£i predictions');
            }
        } catch (err) {
            console.error('Predictions fetch error:', err);
            setError(handle429Error(err));
            return null;
        }
    }, []);

    // Fetch history
    const fetchHistory = useCallback(async (limit = 30, days = 30) => {
        try {
            const params = new URLSearchParams({
                limit: limit.toString(),
                days: days.toString()
            });

            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/history?${params}`);
            const result = await response.json();

            if (result.success) {
                return result.data;
            } else {
                throw new Error(result.message || 'L·ªói khi t·∫£i l·ªãch s·ª≠');
            }
        } catch (err) {
            console.error('History fetch error:', err);
            setError(handle429Error(err));
            return null;
        }
    }, []);

    // Fetch accuracy stats
    const fetchAccuracyStats = useCallback(async (days = 30) => {
        try {
            const params = new URLSearchParams({
                days: days.toString()
            });

            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/accuracy?${params}`);
            const result = await response.json();

            if (result.success) {
                return result.data;
            } else {
                throw new Error(result.message || 'L·ªói khi t·∫£i th·ªëng k√™ ƒë·ªô ch√≠nh x√°c');
            }
        } catch (err) {
            console.error('Accuracy stats fetch error:', err);
            setError(handle429Error(err));
            return null;
        }
    }, []);

    // Load predictions for selected date and method - ALWAYS use ensemble
    const loadPredictions = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);

            // Always use ensemble method for final results
            const predictions = await fetchPredictions(FORCED_METHOD, selectedType, selectedDate, 20);
            if (predictions) {
                setCurrentPredictions(predictions);
                // Fetch extended
                const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/date/${selectedDate}?includeFeatures=true`);
                const data = await response.json();
                if (data.success) {
                    setExtendedFeatures(data.data.extendedFeatures);
                    setLstmStats(data.data.lstmStats || {}); // Gi·∫£ s·ª≠ back-end tr·∫£ th√™m
                }
                console.log('‚úÖ Predictions loaded:', predictions);
            } else {
                // If no predictions found, clear current predictions
                setCurrentPredictions(null);
            }
        } catch (err) {
            console.error('Load predictions error:', err);
            setError(handle429Error(err));
            setCurrentPredictions(null);
        } finally {
            setLoading(false);
        }
    }, [FORCED_METHOD, selectedType, selectedDate, fetchPredictions]);

    // Generate soi c·∫ßu manually (create and save new predictions)
    const generateSoiCau = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);

            console.log('üéØ Generating soi c·∫ßu for date:', currentProcessingDate);

            // Generate new predictions and save to database
            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/generate-soicau`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache'
                },
                body: JSON.stringify({
                    date: currentProcessingDate,
                    method: FORCED_METHOD, // Always use ensemble
                    type: selectedType,
                    limit: 20
                })
            });

            const result = await response.json();

            if (result.success) {
                console.log('‚úÖ Soi c·∫ßu generated and saved successfully:', result.data);

                // Immediately load predictions from API to ensure consistency
                await loadPredictions();

                // Refresh data description ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin m·ªõi
                if (result.data.cached) {
                    setDataDescription({
                        predictionDate: currentProcessingDate,
                        dataSource: `D·ªØ li·ªáu ƒë√£ c√≥ s·∫µn`,
                        explanation: `K·∫øt qu·∫£ soi c·∫ßu cho ng√†y ${formatDisplayDate(currentProcessingDate)} ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng`
                    });
                } else {
                    setDataDescription({
                        predictionDate: currentProcessingDate,
                        dataSource: `üß† Ultra Advanced AI Soi C·∫ßu v2.0`,
                        explanation: `K·∫øt qu·∫£ soi c·∫ßu c·ª±c k·ª≥ cao si√™u cho ng√†y ${formatDisplayDate(currentProcessingDate)} v·ªõi 10 ph∆∞∆°ng ph√°p AI, Neural Networks, Quantum Computing, Genetic Algorithm, Chaos Theory v√† Fractal Analysis`
                    });
                }

                // Refresh dashboard data
                // await fetchDashboardData(); // ƒê√£ x√≥a dashboard
            } else {
                throw new Error(result.message || 'L·ªói khi t·∫°o soi c·∫ßu');
            }
        } catch (err) {
            console.error('Generate soi c·∫ßu error:', err);
            setError(handle429Error(err));
            alert('L·ªói khi t·∫°o soi c·∫ßu: ' + handle429Error(err));
        } finally {
            setLoading(false);
        }
    }, [currentProcessingDate, selectedMethod, selectedType]);

    // Create data collection manually using selected date
    const createDataCollection = useCallback(async () => {
        // Prevent multiple calls
        if (dataCreationLoading) {
            console.log('‚ö†Ô∏è Data creation already in progress, skipping...');
            return;
        }

        try {
            setDataCreationLoading(true);
            setError(null);

            // Use the current processing date to ensure we get the correct date
            const targetDate = currentProcessingDate;
            console.log('üéØ Current processing date:', currentProcessingDate);
            const targetDateObj = new Date(targetDate);
            const yesterday = new Date(targetDateObj);
            yesterday.setDate(yesterday.getDate() - 1);

            // Create data description based on selected date
            const dataDescription = {
                predictionDate: targetDate,
                dataSource: `${formatDisplayDate(yesterday)} tr·ªü v·ªÅ tr∆∞·ªõc`,
                explanation: `D·ªØ li·ªáu d·ª± ƒëo√°n cho ng√†y ${formatDisplayDate(targetDate)} ƒë∆∞·ª£c t·∫°o t·ª´ d·ªØ li·ªáu l·ªãch s·ª≠ t·ª´ ${formatDisplayDate(yesterday)} tr·ªü v·ªÅ tr∆∞·ªõc (ch∆∞a bao g·ªìm k·∫øt qu·∫£ ${formatDisplayDate(yesterday)})`
            };

            console.log('üéØ Creating data collection for date:', targetDate);
            console.log('üìä Data description:', dataDescription);

            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/generate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    date: targetDate,
                    days: 30,
                    topK: 5
                })
            });

            const result = await response.json();

            if (result.success) {
                console.log('‚úÖ Data collection created successfully:', result.data);
                setDataDescription(dataDescription);

                // Update selected date to the target date
                setSelectedDate(targetDate);
                setActiveTab('predictions');

                // Clear current predictions to show that data is ready
                setCurrentPredictions(null);

                if (result.cached) {
                    alert(`‚úÖ D·ªØ li·ªáu ƒë√£ t·ªìn t·∫°i cho ng√†y ${formatDisplayDate(targetDate)}!\n\nüìä B·ªô d·ªØ li·ªáu ƒë√£ c√≥ s·∫µn. Nh·∫•n n√∫t "Soi C·∫ßu" ƒë·ªÉ xem k·∫øt qu·∫£ d·ª± ƒëo√°n.`);
                } else {
                    alert(`‚úÖ T·∫°o b·ªô d·ªØ li·ªáu th√†nh c√¥ng cho ng√†y ${formatDisplayDate(targetDate)}!\n\nüìä B·ªô d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫°o. Nh·∫•n n√∫t "Soi C·∫ßu" ƒë·ªÉ xem k·∫øt qu·∫£ d·ª± ƒëo√°n.`);
                }

                // Kh√¥ng c·∫ßn g·ªçi checkDataExists n·ªØa v√¨ d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng
                // Ch·ªâ c·∫ßn set dataDescription ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin
                setHasDataForSelectedDate(true);
            } else {
                throw new Error(result.message || 'L·ªói khi t·∫°o b·ªô d·ªØ li·ªáu');
            }
        } catch (err) {
            console.error('Create data collection error:', err);
            setError(handle429Error(err));
            setHasDataForSelectedDate(false);

            // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói chi ti·∫øt h∆°n
            let errorMessage = 'L·ªói khi t·∫°o b·ªô d·ªØ li·ªáu: ' + err.message;
            if (err.message.includes('Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu l·ªãch s·ª≠')) {
                errorMessage = `Kh√¥ng th·ªÉ t·∫°o b·ªô d·ªØ li·ªáu cho ng√†y ${formatDisplayDate(targetDate)}.\n\nL√Ω do: Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ x·ªï s·ªë cho kho·∫£ng th·ªùi gian c·∫ßn thi·∫øt.\n\nVui l√≤ng ch·ªçn ng√†y kh√°c ho·∫∑c ki·ªÉm tra xem database c√≥ ƒë·ªß d·ªØ li·ªáu kh√¥ng.`;
            }

            alert(errorMessage);
        } finally {
            setDataCreationLoading(false);
        }
    }, [dataCreationLoading, currentProcessingDate]);

    // Check if data exists for selected date
    const checkDataExists = useCallback(async (date) => {
        try {
            console.log('üîç Checking data exists for date:', date);
            const response = await fetchWithRetry(`${API_BASE_URL}/api/soicau-page/date/${date}`);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();
            console.log('üìä Data check result:', result);

            if (result.success && result.data) {
                // Data exists, set data description but don't load predictions yet
                console.log('‚úÖ Data exists for date:', date);
                setDataDescription({
                    predictionDate: date,
                    dataSource: `D·ªØ li·ªáu ƒë√£ c√≥ s·∫µn`,
                    explanation: `D·ªØ li·ªáu d·ª± ƒëo√°n cho ng√†y ${formatDisplayDate(date)} ƒë√£ ƒë∆∞·ª£c t·∫°o tr∆∞·ªõc ƒë√≥`
                });
                // Don't set currentPredictions here, let user click "Soi C·∫ßu" button
                setCurrentPredictions(null);
                return true;
            } else {
                // No data exists (result.data is null)
                console.log(`üìã No data found for date ${date}: ${result.message || 'No data available'}`);
                setCurrentPredictions(null);
                setDataDescription(null);
                return false;
            }
        } catch (err) {
            console.error('‚ùå Check data exists error:', err);
            setCurrentPredictions(null);
            setDataDescription(null);
            return false;
        }
    }, []);


    // Initial load
    useEffect(() => {
        // fetchDashboardData(); // ƒê√£ x√≥a dashboard
        const initialDate = formatDate(new Date());
        setCurrentProcessingDate(initialDate);
        // Check if data exists for current selected date
        const checkInitialData = async () => {
            try {
                const hasData = await checkDataExists(initialDate);
                setHasDataForSelectedDate(hasData);
            } catch (err) {
                console.error('Error checking initial data:', err);
            } finally {
                setLoading(false); // Quan tr·ªçng: set loading = false sau khi ki·ªÉm tra xong
            }
        };
        checkInitialData();
    }, []); // Only run once on mount

    // Handle date change
    const handleDateChange = async (date) => {
        setSelectedDate(date);
        setCurrentProcessingDate(date);
        setActiveTab('predictions');
        // Clear previous data when changing date
        setDataDescription(null);
        setCurrentPredictions(null);
        // Check if data exists for new date
        const hasData = await checkDataExists(date);
        setHasDataForSelectedDate(hasData);
    };

    // Handle method change
    const handleMethodChange = (method) => {
        setSelectedMethod(method);
        // Load predictions for new method
        loadPredictions();
    };

    // Handle type change
    const handleTypeChange = (type) => {
        setSelectedType(type);
        // Load predictions for new type
        loadPredictions();
    };

    // Format percentage
    const formatPercentage = (value) => {
        return parseFloat(value).toFixed(2) + '%';
    };

    // Get method display name
    const getMethodDisplayName = (method) => {
        const names = {
            cdm: 'CDM (Bayesian c∆° b·∫£n)',
            efdm: 'EFDM (Extended Flexible)',
            cf: 'Collaborative Filtering',
            ensemble: 'üéØ Ensemble (K·∫øt h·ª£p t·∫•t c·∫£)',
            advanced: 'ü§ñ Advanced Soi C·∫ßu (7 ph∆∞∆°ng ph√°p AI)'
        };
        return names[method] || method;
    };

    // Get type display name
    const getTypeDisplayName = (type) => {
        return type === 'de' ? 'ƒê·ªÅ (2 s·ªë cu·ªëi gi·∫£i ƒë·∫∑c bi·ªát)' : 'L√¥ (2 s·ªë cu·ªëi t·∫•t c·∫£ gi·∫£i)';
    };

    // Calculate algorithm statistics for one day
    const calculateAlgorithmStats = useCallback((predictions) => {
        if (!predictions || !predictions.predictions) {
            return null;
        }

        const preds = predictions.predictions;
        const method = predictions.method;

        // Calculate statistics
        const totalPredictions = preds.length;
        const avgProbability = preds.reduce((sum, p) => sum + parseFloat(p.percentage), 0) / totalPredictions;
        const maxProbability = Math.max(...preds.map(p => parseFloat(p.percentage)));
        const minProbability = Math.min(...preds.map(p => parseFloat(p.percentage)));
        const stdDev = Math.sqrt(preds.reduce((sum, p) => sum + Math.pow(parseFloat(p.percentage) - avgProbability, 2), 0) / totalPredictions);

        // Calculate confidence score (higher is better)
        const confidenceScore = (avgProbability / stdDev) * (maxProbability / avgProbability);

        // Calculate prediction quality score
        const qualityScore = (avgProbability * 0.4) + (confidenceScore * 0.3) + ((maxProbability - minProbability) * 0.3);

        // Calculate occurrence probability (normalized to 0-1 range)
        const occurrenceProbability = Math.min(1.0, (maxProbability * 0.6 + avgProbability * 0.4) / 100);

        return {
            method,
            totalPredictions,
            avgProbability: avgProbability.toFixed(2),
            maxProbability: maxProbability.toFixed(2),
            minProbability: minProbability.toFixed(2),
            stdDev: stdDev.toFixed(2),
            confidenceScore: confidenceScore.toFixed(2),
            qualityScore: qualityScore.toFixed(2),
            occurrenceProbability: occurrenceProbability.toFixed(4),
            recommendation: qualityScore > 25 ? 'Xu·∫•t s·∫Øc' : qualityScore > 20 ? 'T·ªët' : qualityScore > 15 ? 'Kh√°' : 'Trung b√¨nh'
        };
    }, []);

    // Render algorithm statistics
    const renderAlgorithmStats = (predictions) => {
        const stats = calculateAlgorithmStats(predictions);
        if (!stats) return null;

        const getRecommendationColor = (recommendation) => {
            switch (recommendation) {
                case 'Xu·∫•t s·∫Øc': return '#28a745';
                case 'T·ªët': return '#17a2b8';
                case 'Kh√°': return '#ffc107';
                case 'Trung b√¨nh': return '#dc3545';
                default: return '#6c757d';
            }
        };

        return (
            <div className={styles.algorithmStats}>
                <h4>üìä Th·ªëng K√™ Thu·∫≠t To√°n {getMethodDisplayName(stats.method)}</h4>
                <div className={styles.statsGrid}>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>T·ªïng D·ª± ƒêo√°n</div>
                        <div className={styles.statValue}>{stats.totalPredictions}</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>X√°c Su·∫•t Trung B√¨nh</div>
                        <div className={styles.statValue}>{stats.avgProbability}%</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>X√°c Su·∫•t Cao Nh·∫•t</div>
                        <div className={styles.statValue}>{stats.maxProbability}%</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>X√°c Su·∫•t Th·∫•p Nh·∫•t</div>
                        <div className={styles.statValue}>{stats.minProbability}%</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>ƒê·ªô L·ªách Chu·∫©n</div>
                        <div className={styles.statValue}>{stats.stdDev}%</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>ƒêi·ªÉm Tin C·∫≠y</div>
                        <div className={styles.statValue}>{stats.confidenceScore}</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>ƒêi·ªÉm Ch·∫•t L∆∞·ª£ng</div>
                        <div className={styles.statValue}>{stats.qualityScore}</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>Kh·∫£ NƒÉng Ra S·ªë</div>
                        <div className={styles.statValue}>{Math.min(100, parseFloat(stats.occurrenceProbability) * 100).toFixed(2)}%</div>
                    </div>
                    <div className={styles.statCard}>
                        <div className={styles.statLabel}>ƒê√°nh Gi√°</div>
                        <div
                            className={styles.statValue}
                            style={{ color: getRecommendationColor(stats.recommendation) }}
                        >
                            {stats.recommendation}
                        </div>
                    </div>
                </div>
                <div className={styles.recommendationBox}>
                    <div className={styles.recommendationTitle}>üéØ Khuy·∫øn Ngh·ªã:</div>
                    <div className={styles.recommendationText}>
                        {stats.recommendation === 'Xu·∫•t s·∫Øc' && 'Thu·∫≠t to√°n n√†y cho k·∫øt qu·∫£ d·ª± ƒëo√°n r·∫•t t·ªët v·ªõi ƒë·ªô tin c·∫≠y cao. N√™n ∆∞u ti√™n s·ª≠ d·ª•ng.'}
                        {stats.recommendation === 'T·ªët' && 'Thu·∫≠t to√°n n√†y cho k·∫øt qu·∫£ d·ª± ƒëo√°n t·ªët v·ªõi ƒë·ªô tin c·∫≠y kh√° cao. C√≥ th·ªÉ tin t∆∞·ªüng.'}
                        {stats.recommendation === 'Kh√°' && 'Thu·∫≠t to√°n n√†y cho k·∫øt qu·∫£ d·ª± ƒëo√°n kh√° t·ªët. C·∫ßn c√¢n nh·∫Øc th√™m.'}
                        {stats.recommendation === 'Trung b√¨nh' && 'Thu·∫≠t to√°n n√†y cho k·∫øt qu·∫£ d·ª± ƒëo√°n trung b√¨nh. N√™n k·∫øt h·ª£p v·ªõi ph∆∞∆°ng ph√°p kh√°c.'}
                    </div>
                </div>
            </div>
        );
    };

    // Render prediction card with statistical confidence - Memoized for performance
    const renderPredictionCard = useCallback((prediction, index, key, isHit = false) => {
        const isTop3 = index < 3;
        const cardClass = isTop3 ? styles.topPrediction : styles.prediction;
        const hitClass = isHit ? styles.hit : '';

        const hotCold = extendedFeatures?.hotCold[prediction.number] || 'normal';
        const badgeClass = hotCold === 'hot' ? styles.hotBadge : hotCold === 'cold' ? styles.coldBadge : '';

        // T√≠nh ƒë·ªô tin c·∫≠y d·ª±a tr√™n x√°c su·∫•t - C·∫≠p nh·∫≠t cho realistic scoring
        const probability = parseFloat(prediction.percentage) || 0;
        let confidenceLevel = 'Th·∫•p';
        let confidenceColor = '#dc3545';

        if (probability >= 10.0) {
            confidenceLevel = 'R·∫•t Cao';
            confidenceColor = '#28a745';
        } else if (probability >= 7.0) {
            confidenceLevel = 'Cao';
            confidenceColor = '#17a2b8';
        } else if (probability >= 4.0) {
            confidenceLevel = 'Trung B√¨nh';
            confidenceColor = '#ffc107';
        } else if (probability >= 2.0) {
            confidenceLevel = 'Th·∫•p-Trung B√¨nh';
            confidenceColor = '#fd7e14';
        }

        // Hi·ªÉn th·ªã th√¥ng tin ƒë·ªôc ƒë√°o n·∫øu c√≥
        const uniquenessInfo = prediction.uniqueness ? (
            <div style={{
                fontSize: '10px',
                color: prediction.uniqueness > 1.2 ? '#e74c3c' : prediction.uniqueness > 1.0 ? '#f39c12' : '#95a5a6',
                marginTop: '2px',
                fontWeight: 'bold'
            }}>
                {prediction.uniqueness > 1.2 ? 'üî•' : prediction.uniqueness > 1.0 ? '‚≠ê' : 'üí´'}
                {(prediction.uniqueness * 100).toFixed(0)}%
            </div>
        ) : null;

        // Hi·ªÉn th·ªã special note n·∫øu c√≥
        const specialNote = prediction.specialNote ? (
            <div style={{
                fontSize: '9px',
                color: '#7f8c8d',
                marginTop: '2px',
                fontStyle: 'italic'
            }}>
                {prediction.specialNote}
            </div>
        ) : null;

        return (
            <div key={key} className={`${cardClass} ${hitClass}`}>
                <div className={styles.predictionNumber}>
                    {prediction.number}
                </div>
                <div className={styles.predictionPercentage}>
                    {formatPercentage(prediction.percentage)}
                </div>
                {isTop3 && (
                    <div className={styles.topBadge}>
                        Top {index + 1}
                    </div>
                )}
                {isHit && (
                    <div className={styles.hitBadge}>
                        Tr√∫ng
                    </div>
                )}
                <div className={badgeClass}>{hotCold}</div>
                <div style={{
                    fontSize: '11px',
                    color: confidenceColor,
                    marginTop: '4px',
                    fontWeight: 'bold'
                }}>
                    ‚≠ê {confidenceLevel}
                </div>
                {uniquenessInfo}
                {specialNote}
            </div>
        );
    }, [extendedFeatures, styles]);



    // Memoized predictions render to keep hooks order stable
    const memoizedPredictionCards = useMemo(() => {
        if (!currentPredictions || !currentPredictions.predictions) return null;
        return currentPredictions.predictions.map((prediction, index) =>
            renderPredictionCard(prediction, index, `${prediction.number}-${index}`)
        );
    }, [currentPredictions, renderPredictionCard]);

    // Render extended features
    const renderExtendedFeatures = () => {
        if (!extendedFeatures) return null;
        return (
            <div className={styles.extendedSection}>
                <h4>üìä Extended Features</h4>
                <div>Top Hot: {Object.keys(extendedFeatures.hotCold).filter(n => extendedFeatures.hotCold[n] === 'hot').slice(0, 5).join(', ')}</div>
                <div>Top Cold: {Object.keys(extendedFeatures.hotCold).filter(n => extendedFeatures.hotCold[n] === 'cold').slice(0, 5).join(', ')}</div>
                {/* T∆∞∆°ng t·ª± cho positionStats */}
            </div>
        );
    }

    if (loading) {
        return <LoadingSpinner />;
    }

    if (error) {
        return <ErrorMessage message={error} onRetry={() => window.location.reload()} />;
    }

    return (
        <Layout>
            <PerformanceMonitor />
            <Head>
                <title>Soi C·∫ßu AI - D·ª± ƒêo√°n XSMB H√¥m Nay</title>
                <meta name="description" content="Soi c·∫ßu XSMB s·ª≠ d·ª•ng thu·∫≠t to√°n AI (CDM, EFDM, Collaborative Filtering, Ensemble) v·ªõi ƒë·ªô ch√≠nh x√°c cao" />
                <meta name="keywords" content="soi c·∫ßu, d·ª± ƒëo√°n, xsmb, bayesian, cdm, efdm, collaborative filtering, ensemble" />
            </Head>

            <div className={styles.container}>

                <div className={styles.header}>
                    <h1 className={styles.title}>Soi C·∫ßu AI XSMB</h1>
                    <p className={styles.subtitle}>
                        D·ª± ƒëo√°n XSMB s·ª≠ d·ª•ng thu·∫≠t to√°n AI ti√™n ti·∫øn v·ªõi ƒë·ªô ch√≠nh x√°c cao
                    </p>
                </div>



                {/* Predictions Tab */}
                <div className={styles.predictions}>
                    <div className={styles.predictionsHeader}>
                        <div className={styles.dateSelector}>
                            <label>Ch·ªçn ng√†y:</label>
                            <input
                                type="date"
                                value={selectedDate}
                                onChange={(e) => handleDateChange(e.target.value)}
                                max={formatDate(new Date())}
                            />
                        </div>

                        {/* Type selector - ƒê·ªÄ ho·∫∑c L√î */}
                        <div className={styles.typeSelector}>
                            <label>Lo·∫°i d·ª± ƒëo√°n:</label>
                            <select
                                value={selectedType}
                                onChange={(e) => handleTypeChange(e.target.value)}
                            >
                                <option value="de">üéØ ƒê·ªÅ (2 s·ªë cu·ªëi gi·∫£i ƒë·∫∑c bi·ªát)</option>
                                <option value="lo">üé≤ L√¥ (2 s·ªë cu·ªëi t·∫•t c·∫£ gi·∫£i)</option>
                            </select>
                        </div>

                        {/* Hidden - Always use ensemble for final results */}
                        <div style={{ display: 'none' }}>
                            <label>Ph∆∞∆°ng ph√°p:</label>
                            <select value={FORCED_METHOD} onChange={() => { }}>
                                <option value="ensemble">üéØ Ensemble (T·ªïng h·ª£p AI)</option>
                            </select>
                        </div>

                        <div className={styles.actionButtons}>
                            {!hasDataForSelectedDate && (
                                <button
                                    className={styles.generateButton}
                                    onClick={createDataCollection}
                                    disabled={dataCreationLoading || loading}
                                >
                                    {dataCreationLoading ? 'ƒêang t·∫°o b·ªô d·ªØ li·ªáu...' : 'T·∫°o B·ªô D·ªØ Li·ªáu'}
                                </button>
                            )}
                            <button
                                className={styles.generateButton}
                                onClick={generateSoiCau}
                                disabled={loading || !hasDataForSelectedDate}
                            >
                                {loading ? 'ƒêang t·∫°o soi c·∫ßu...' : 'Soi C·∫ßu'}
                            </button>
                        </div>
                    </div>

                    <div className={styles.predictionsContent}>
                        <div className={styles.predictionsHeader}>
                            <div>
                                <h3>üéØ K·∫øt Qu·∫£ Soi C·∫ßu T·ªïng H·ª£p AI - {getTypeDisplayName(selectedType)}</h3>
                                <p>üìÖ Ng√†y: {formatDisplayDate(selectedDate)}</p>
                                <p style={{ color: '#28a745', fontSize: '14px', marginTop: '8px' }}>
                                    ‚ú® T√≠ch h·ª£p t·∫•t c·∫£ ph∆∞∆°ng ph√°p: CDM, EFDM, CF, Advanced (7 methods), LSTM
                                </p>
                            </div>
                        </div>


                        {/* Predictions will be loaded here */}
                        {currentPredictions && currentPredictions.predictions ? (
                            <>
                                <div className={styles.predictionGrid}>
                                    {memoizedPredictionCards}
                                </div>
                                {/* Algorithm Statistics */}
                                {renderAlgorithmStats(currentPredictions)}

                                {/* Extended Features */}
                                {renderExtendedFeatures()}

                                {/* Probability Statistics Component - Show all methods */}
                                <Suspense fallback={<div className={styles.loading}>ƒêang t·∫£i th·ªëng k√™...</div>}>
                                    <ProbabilityStatistics
                                        date={currentProcessingDate}
                                        showAllMethods={true}
                                    />
                                </Suspense>
                            </>
                        ) : hasDataForSelectedDate ? (
                            <div className={styles.noData}>
                                <h3>üìä B·ªô D·ªØ Li·ªáu ƒê√£ S·∫µn S√†ng</h3>
                                <p>B·ªô d·ªØ li·ªáu cho ng√†y {formatDisplayDate(currentProcessingDate)} ƒë√£ c√≥ s·∫µn.</p>
                                <p>Nh·∫•n n√∫t "Soi C·∫ßu" ·ªü tr√™n ƒë·ªÉ xem k·∫øt qu·∫£ d·ª± ƒëo√°n.</p>
                            </div>
                        ) : (
                            <div className={styles.noData}>
                                <h3>Ch∆∞a c√≥ d·ªØ li·ªáu d·ª± ƒëo√°n</h3>
                                <p>Nh·∫•n n√∫t "T·∫°o B·ªô D·ªØ Li·ªáu" ·ªü tr√™n ƒë·ªÉ t·∫°o d·ªØ li·ªáu cho ng√†y {formatDisplayDate(currentProcessingDate)}</p>
                                <p>Sau khi t·∫°o b·ªô d·ªØ li·ªáu, nh·∫•n n√∫t "Soi C·∫ßu" ƒë·ªÉ xem k·∫øt qu·∫£ d·ª± ƒëo√°n.</p>
                            </div>
                        )}
                    </div>
                </div>

            </div>
        </Layout>
    );
};

export default SoiCauBayesian;
